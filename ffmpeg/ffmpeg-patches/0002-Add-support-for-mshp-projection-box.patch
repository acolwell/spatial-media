From cd1e5d2af1afc253aae7c14f39617c3906b2f76a Mon Sep 17 00:00:00 2001
From: Aaron Colwell <acolwell@google.com>
Date: Fri, 30 Jun 2017 15:02:22 -0700
Subject: [PATCH] Add support for mshp projection box.

---
 ffmpeg_opt.c          | 50 ++++++++++++++++++++++++++++++++++++++++++++++++--
 libavformat/dump.c    |  2 ++
 libavformat/mov.c     | 32 +++++++++++++++++++++++++++++++-
 libavformat/movenc.c  |  9 ++++++++-
 libavutil/spherical.c |  1 +
 libavutil/spherical.h | 21 +++++++++++++++++++++
 6 files changed, 111 insertions(+), 4 deletions(-)

diff --git a/ffmpeg_opt.c b/ffmpeg_opt.c
index 4bc5104..2366191 100644
--- a/ffmpeg_opt.c
+++ b/ffmpeg_opt.c
@@ -1604,6 +1604,8 @@ static int set_spherical_mapping(const char* opt, OutputStream *ost) {
         int64_t padding;
 
         int stereo_mode;
+
+        const char* mesh_filename;
     } SphericalMappingContext;
 
 #define OFFSET(x) offsetof(SphericalMappingContext, x)
@@ -1611,13 +1613,15 @@ static int set_spherical_mapping(const char* opt, OutputStream *ost) {
 
     static const AVOption opts[] = {
         { "projection", "projection", OFFSET(projection), AV_OPT_TYPE_INT,
-            { .i64 = -1 }, -1, AV_SPHERICAL_EQUIRECTANGULAR_TILE, FLAGS, "projection" },
+            { .i64 = -1 }, -1, AV_SPHERICAL_MESH, FLAGS, "projection" },
         { "equirectangular", "equirectangular projection", 0, AV_OPT_TYPE_CONST,
             { .i64 = AV_SPHERICAL_EQUIRECTANGULAR }, INT_MIN, INT_MAX, FLAGS, "projection" },
         { "cubemap", "cubemap projection", 0, AV_OPT_TYPE_CONST,
             { .i64 = AV_SPHERICAL_CUBEMAP }, INT_MIN, INT_MAX, FLAGS, "projection" },
         { "equirectangular_tile", "tiled equirectangular projection", 0, AV_OPT_TYPE_CONST,
             { .i64 = AV_SPHERICAL_EQUIRECTANGULAR_TILE }, INT_MIN, INT_MAX, FLAGS, "projection" },
+        { "mesh", "mesh projection", 0, AV_OPT_TYPE_CONST,
+            { .i64 = AV_SPHERICAL_MESH }, INT_MIN, INT_MAX, FLAGS, "projection" },
         { "yaw", "initial yaw orientation in degrees", OFFSET(yaw), AV_OPT_TYPE_DOUBLE,
             { .dbl = 0.0 }, -180.0, 180.0, FLAGS },
         { "pitch", "initial pitch orientation in degrees", OFFSET(pitch), AV_OPT_TYPE_DOUBLE,
@@ -1640,6 +1644,8 @@ static int set_spherical_mapping(const char* opt, OutputStream *ost) {
             { .i64 = AV_STEREO3D_TOPBOTTOM }, INT_MIN, INT_MAX, FLAGS, "stereo_mode" },
         { "left-right", "Left/Right stereo mode", 0, AV_OPT_TYPE_CONST,
             { .i64 = AV_STEREO3D_SIDEBYSIDE }, INT_MIN, INT_MAX, FLAGS, "stereo_mode" },
+        { "mesh_filename", "mesh filename", OFFSET(mesh_filename), AV_OPT_TYPE_STRING,
+            { .str = NULL }, CHAR_MIN, CHAR_MAX, FLAGS },
         { NULL }
     };
 #undef OFFSET
@@ -1685,7 +1691,47 @@ static int set_spherical_mapping(const char* opt, OutputStream *ost) {
         return AVERROR(EINVAL);
     }
 
-    spherical_mapping = av_spherical_alloc(&spherical_mapping_size);
+    if (ctx.projection == AV_SPHERICAL_MESH) {
+        AVIOContext *mesh_file_ctx;
+        if (ctx.mesh_filename == NULL) {
+            av_log(NULL, AV_LOG_ERROR, "mesh_filename must be specified for AV_SPHERICAL_MESH projection.\n");
+            return AVERROR(EINVAL);
+        }
+
+        ret = avio_open(&mesh_file_ctx, ctx.mesh_filename, AVIO_FLAG_READ);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "Failed to open mesh file '%s'.\n", ctx.mesh_filename);
+            return ret;
+        }
+
+        int64_t mesh_size = avio_size(mesh_file_ctx);
+        if (mesh_size > 0) {
+            spherical_mapping_size = sizeof(AVSphericalMapping) + mesh_size;
+            spherical_mapping = av_mallocz(spherical_mapping_size);
+            if (spherical_mapping) {
+                spherical_mapping->mesh_size = mesh_size;
+                ret = avio_read(mesh_file_ctx,
+                                spherical_mapping->mesh_data,
+                                spherical_mapping->mesh_size);
+            } else {
+                ret = AVERROR(ENOMEM);
+            }
+        } else {
+            av_log(NULL, AV_LOG_ERROR, "Invalid mesh_size %d.\n", mesh_size);
+            ret = AVERROR(EINVAL);
+        }
+
+        avio_closep(&mesh_file_ctx);
+        if (ret < 0) {
+            if (spherical_mapping)
+                av_freep(&spherical_mapping);
+
+	    return ret;
+	}
+    } else {
+        spherical_mapping = av_spherical_alloc(&spherical_mapping_size);
+    }
+
     if (!spherical_mapping)
         return AVERROR(ENOMEM);
 
diff --git a/libavformat/dump.c b/libavformat/dump.c
index 77043e3..e79d724 100644
--- a/libavformat/dump.c
+++ b/libavformat/dump.c
@@ -375,6 +375,8 @@ static void dump_spherical(void *ctx, AVCodecParameters *par, AVPacketSideData *
         av_log(ctx, AV_LOG_INFO, "[%zu, %zu, %zu, %zu] ", l, t, r, b);
     } else if (spherical->projection == AV_SPHERICAL_CUBEMAP) {
         av_log(ctx, AV_LOG_INFO, "[pad %"PRIu32"] ", spherical->padding);
+    } else if (spherical->projection == AV_SPHERICAL_MESH) {
+        av_log(ctx, AV_LOG_INFO, "[mesh size %"PRIu32"] ", spherical->mesh_size);
     }
 }
 
diff --git a/libavformat/mov.c b/libavformat/mov.c
index 899690d..6f9a702 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -4828,6 +4828,7 @@ static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     uint32_t l = 0, t = 0, r = 0, b = 0;
     uint32_t tag, padding = 0;
     enum AVSphericalProjection projection;
+    uint32_t version_flags = 0;
 
     if (c->fc->nb_streams < 1)
         return 0;
@@ -4871,7 +4872,7 @@ static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)
         av_log(c->fc, AV_LOG_ERROR, "Missing projection header box\n");
         return 0;
     }
-    avio_skip(pb, 4); /*  version + flags */
+    version_flags = avio_rb32(pb); /*  version + flags */
 
     /* 16.16 fixed point */
     yaw   = avio_rb32(pb);
@@ -4913,6 +4914,9 @@ static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)
         else
             projection = AV_SPHERICAL_EQUIRECTANGULAR;
         break;
+    case MKTAG('m','s','h','p'):
+        projection = AV_SPHERICAL_MESH;
+        break;
     default:
         av_log(c->fc, AV_LOG_ERROR, "Unknown projection type\n");
         return 0;
@@ -4935,6 +4939,32 @@ static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     sc->spherical->bound_right  = r;
     sc->spherical->bound_bottom = b;
 
+    if (projection == AV_SPHERICAL_MESH) {
+        const uint32_t kMaxMeshSize = 4 << 20;
+        int ret = 0;
+        const uint32_t mesh_size = size - 8;
+        if (size <= 8 || sc->spherical_size > kMaxMeshSize) {
+            av_log(c->fc, AV_LOG_ERROR,
+                   "Invalid size (%d <= 8) or invalid mesh size (%d > %d)\n",
+                   size, mesh_size, kMaxMeshSize);
+            return AVERROR_INVALIDDATA;
+        }
+        const int spherical_size = sizeof(AVSphericalMapping) + mesh_size;
+        AVSphericalMapping* spherical = av_mallocz(spherical_size);
+        if (!spherical)
+            return AVERROR(ENOMEM);
+        memcpy(spherical, sc->spherical, sc->spherical_size);
+        av_freep(&sc->spherical);
+        sc->spherical = spherical;
+        sc->spherical_size = spherical_size;
+
+        AV_WB32(sc->spherical->mesh_data, version_flags);
+        ret = avio_read(pb, sc->spherical->mesh_data + 4, mesh_size - 4);
+        if (ret < 0)
+            return ret;
+        sc->spherical->mesh_size = mesh_size;
+    }
+
     return 0;
 }
 
diff --git a/libavformat/movenc.c b/libavformat/movenc.c
index 9c3e643..7ade5b1 100644
--- a/libavformat/movenc.c
+++ b/libavformat/movenc.c
@@ -1620,7 +1620,8 @@ static int mov_write_sv3d_tag(AVFormatContext *s, AVIOContext *pb, AVSphericalMa
 
     if (spherical_mapping->projection != AV_SPHERICAL_EQUIRECTANGULAR &&
         spherical_mapping->projection != AV_SPHERICAL_EQUIRECTANGULAR_TILE &&
-        spherical_mapping->projection != AV_SPHERICAL_CUBEMAP) {
+        spherical_mapping->projection != AV_SPHERICAL_CUBEMAP &&
+        spherical_mapping->projection != AV_SPHERICAL_MESH) {
         av_log(pb, AV_LOG_WARNING, "Unsupported projection %d. sv3d not written.\n", spherical_mapping->projection);
         return 0;
     }
@@ -1665,6 +1666,12 @@ static int mov_write_sv3d_tag(AVFormatContext *s, AVIOContext *pb, AVSphericalMa
         avio_wb32(pb, 0); /* layout */
         avio_wb32(pb, spherical_mapping->padding); /* padding */
         break;
+      case AV_SPHERICAL_MESH:
+        avio_wb32(pb, 8 + spherical_mapping->mesh_size);    /* size */
+        ffio_wfourcc(pb, "mshp");
+        avio_write(pb, spherical_mapping->mesh_data,
+                   spherical_mapping->mesh_size);
+        break;
     }
     update_size(pb, proj_pos);
 
diff --git a/libavutil/spherical.c b/libavutil/spherical.c
index 4be55f3..4b34d1b 100644
--- a/libavutil/spherical.c
+++ b/libavutil/spherical.c
@@ -55,6 +55,7 @@ static const char *spherical_projection_names[] = {
     [AV_SPHERICAL_EQUIRECTANGULAR]      = "equirectangular",
     [AV_SPHERICAL_CUBEMAP]              = "cubemap",
     [AV_SPHERICAL_EQUIRECTANGULAR_TILE] = "tiled equirectangular",
+    [AV_SPHERICAL_MESH]                 = "mesh",
 };
 
 const char *av_spherical_projection_name(enum AVSphericalProjection projection)
diff --git a/libavutil/spherical.h b/libavutil/spherical.h
index cef759c..1dbc989 100644
--- a/libavutil/spherical.h
+++ b/libavutil/spherical.h
@@ -70,6 +70,11 @@ enum AVSphericalProjection {
      * the position of the current video in a larger surface.
      */
     AV_SPHERICAL_EQUIRECTANGULAR_TILE,
+
+    /**
+     * Video represents a texture mapped to a projection mesh.
+     */
+    AV_SPHERICAL_MESH,
 };
 
 /**
@@ -180,6 +185,22 @@ typedef struct AVSphericalMapping {
      *       cases.
      */
     uint32_t padding;
+
+    /**
+     * @name Projection mesh
+     * @anchor projection_mesh
+     * @{
+     * These fields indicate the size and contents of the mshp projection box.
+     *
+     * @note This value is valid for only for the mesh projection type
+     *       (@ref AV_SPHERICAL_MESH), and should be ignored in all other
+     *       cases.
+     */
+    uint32_t mesh_size;
+    uint8_t mesh_data[];
+    /**
+     * @}
+     */
 } AVSphericalMapping;
 
 /**
-- 
2.7.4

